/**
 * schema-tools.ts — Claude tool definitions for HTML enhancement + schema extraction
 *
 * Uses tool_use to have Claude analyze HTML, detect business type, extract schema data,
 * and enhance HTML with semantic markup. The schema JSON-LD is then generated
 * deterministically by the registry.
 */

import type Anthropic from '@anthropic-ai/sdk';

export interface EnhancePageInput {
  // Schema detection
  detectedType: string;
  schemaType?: string;

  // Extracted business data
  businessName: string;
  description: string;
  address?: string;
  phone?: string;
  email?: string;
  priceRange?: '$' | '$$' | '$$$' | '$$$$';
  hours?: string;
  services?: string[];
  faqs?: { question: string; answer: string }[];

  // Enhanced HTML output
  enhancedHtml: string;

  // SEO meta
  seoTitle?: string;
  seoDescription?: string;

  // Changes log
  changes?: string[];
}

export const ENHANCEMENT_TOOLS: Anthropic.Tool[] = [
  {
    name: 'enhance_page',
    description: `Analyze HTML, detect business type, extract schema data, AND enhance the HTML.

You must:
1. Detect the business/component type from content
2. Extract all relevant business data for Schema.org
3. Enhance the HTML with semantic fixes (headings, ARIA, microdata)
4. Return both the enhanced HTML and extracted schema data

The schema JSON-LD will be generated by the registry from your extracted data.`,
    input_schema: {
      type: 'object' as const,
      properties: {
        // Schema detection
        detectedType: {
          type: 'string' as const,
          description: 'Business type detected (e.g., "yoga studio", "restaurant", "law firm", "saas")'
        },
        schemaType: {
          type: 'string' as const,
          description: 'Schema.org type if known (e.g., "Restaurant", "LegalService"). Leave empty to auto-detect.'
        },

        // Extracted business data
        businessName: { type: 'string' as const, description: 'Business or organization name' },
        description: { type: 'string' as const, description: 'Business/page description (150-160 chars for SEO)' },
        address: { type: 'string' as const, description: 'Full address if found' },
        phone: { type: 'string' as const, description: 'Phone number if found' },
        email: { type: 'string' as const, description: 'Email address if found' },
        priceRange: {
          type: 'string' as const,
          enum: ['$', '$$', '$$$', '$$$$'],
          description: 'Price range indicator'
        },
        hours: { type: 'string' as const, description: 'Business hours if found' },
        services: {
          type: 'array' as const,
          items: { type: 'string' as const },
          description: 'Services extracted from content'
        },
        faqs: {
          type: 'array' as const,
          items: {
            type: 'object' as const,
            properties: {
              question: { type: 'string' as const },
              answer: { type: 'string' as const }
            },
            required: ['question', 'answer']
          },
          description: 'FAQ items from accordion/details elements'
        },

        // Enhanced HTML output
        enhancedHtml: {
          type: 'string' as const,
          description: 'The complete enhanced HTML document with: fixed heading hierarchy, ARIA labels on sections, alt text on images, microdata attributes (itemscope/itemprop), proper Bootstrap grid nesting'
        },

        // SEO meta
        seoTitle: { type: 'string' as const, description: 'Optimized page title (50-60 chars)' },
        seoDescription: { type: 'string' as const, description: 'Meta description (150-160 chars)' },

        // Changes log
        changes: {
          type: 'array' as const,
          items: { type: 'string' as const },
          description: 'List of enhancements made'
        }
      },
      required: ['detectedType', 'businessName', 'description', 'enhancedHtml']
    }
  }
];

export const ENHANCEMENT_SYSTEM_PROMPT = `You are a web standards expert. Enhance HTML for SEO, accessibility, and Schema.org.

CRITICAL RULES:
- Fix heading hierarchy (h1 → h2 → h3, never skip levels)
- Add aria-label/aria-labelledby to sections
- Add alt text to images missing it
- Add microdata: itemscope, itemtype, itemprop where appropriate
- Ensure Bootstrap responsive classes (col-md-*, col-lg-*)
- Preserve ALL content, layout, and styling
- Output complete <!DOCTYPE html> document

IMAGE LAZY LOADING:
- Add loading="lazy" to images BELOW the fold (not in hero sections)
- Do NOT add loading="lazy" to images in the first section/hero
- Do NOT add loading="lazy" to images in the viewport on initial load
- Hero images, logo images, and LCP images should NOT have lazy loading

EXTRACTION:
- Extract business name from h1, logo, or meta tags
- Extract description from meta description or first paragraph
- Extract contact info (phone, email, address) from footer or contact sections
- Extract services from service/features sections
- Extract FAQs from accordion or details elements

DO NOT:
- Change text content, image URLs, colors, or layout structure
- Remove any existing content
- Add placeholder content`;

/**
 * Components that should NOT have lazy loading on their images
 * (above-the-fold content)
 */
export const NO_LAZY_LOAD_COMPONENTS = [
  'hero',
  'header',
  'navbar',
  'navigation',
  'banner',
  'masthead',
  'jumbotron',
];

/**
 * Check if a component type should have lazy loading disabled
 */
export function shouldDisableLazyLoad(componentType: string): boolean {
  const typeLower = (componentType || '').toLowerCase();
  return NO_LAZY_LOAD_COMPONENTS.some(c => typeLower.includes(c));
}

/**
 * Add lazy loading to images in HTML (for below-fold content)
 */
export function addLazyLoadingToImages(html: string, isAboveFold: boolean = false): string {
  if (isAboveFold) {
    // Remove any existing lazy loading for above-fold content
    return html.replace(/\s+loading\s*=\s*["']lazy["']/gi, '');
  }

  // Add lazy loading to images that don't already have it
  return html.replace(
    /<img\s+([^>]*?)(?!\s*loading\s*=)([^>]*?)>/gi,
    (match, before, after) => {
      // Don't add to images that already have loading attribute
      if (/loading\s*=/i.test(before) || /loading\s*=/i.test(after)) {
        return match;
      }
      return `<img ${before}loading="lazy" ${after}>`;
    }
  );
}

/**
 * Process HTML to add lazy loading based on section position
 */
export function processLazyLoading(html: string): string {
  // Split by sections
  const sectionPattern = /<section[^>]*>[\s\S]*?<\/section>/gi;
  let sectionIndex = 0;

  return html.replace(sectionPattern, (sectionHtml) => {
    const isFirstSection = sectionIndex === 0;
    sectionIndex++;

    // Check if this section looks like a hero/header
    const isHeroLike = /<section[^>]*class\s*=\s*["'][^"']*(?:hero|header|banner|masthead|jumbotron)[^"']*["']/i.test(sectionHtml);

    if (isFirstSection || isHeroLike) {
      // Remove lazy loading from first/hero sections
      return addLazyLoadingToImages(sectionHtml, true);
    } else {
      // Add lazy loading to other sections
      return addLazyLoadingToImages(sectionHtml, false);
    }
  });
}
